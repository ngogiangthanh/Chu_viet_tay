#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_1_k40_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 80L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 80L)))
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 40L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = dtw(), centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
help(tsclust)
pc.dtwlb <- tsclust(pp_series, k = 40L,
dtw(), centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "dtw(window.type='sakoechiba')", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "dtw(window.type=sakoechiba)", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\author_2_k40_projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_2_k40_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
library("dtwclust", lib.loc="~/R/win-library/3.4")
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 40L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\author_2_k40_projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_2_k40_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 40L,
distance = "lbk", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 40L,
distance = "lbk", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 40L,
distance = "lbi", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 40L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
methods(dtw_lb)
methods(dtwclust())
methods(dtwclust::dtw_lb()
)
methods(dtwclust::dtw_lb);
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\author_1_k10_projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_1_k10_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 10L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 10L)))
#plot(pc.dtwlb)
library("dtwclust", lib.loc="~/R/win-library/3.4")
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 10L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 10L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 10L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 10L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\author_2_k10_projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_2_k10_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 10L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 10L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-pp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/projection_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/projection_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 10L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 10L)))
#plot(pc.dtwlb)
#save
rs.Idx<-pc.dtwlb@cluster
rs.val<-wp_series
rs <- list();
for (i in 1:length(rs.Idx)) {
rs[[i]] <-  c(names(rs.val[i]), rs.Idx[i])
}
lapply(rs, write, "d:/word_profiles_clustering_dtw.txt", append=TRUE, ncolumns=1000)
lapply(pc.dtwlb@centroids, write, "d:/word_profiles_centroids_dtw.txt", append=TRUE, ncolumns=1000)
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\author_2_k20_projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\author_2_k20_word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 20L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 20L)))
#plot(pc.dtwlb)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 20L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 20L)))
#plot(pc.dtwlb)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
pc.dtwlb <- tsclust(pp_series, k = 20L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 20L)))
#plot(pc.dtwlb)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
# Reinterpolate series to equal length and normalize
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pc.dtwlb <- tsclust(wp_series, k = 20L,
distance = "dtw", centroid = "pam",
seed = 3247, trace = TRUE,
control = partitional_control(pam.precompute = FALSE),
args = tsclust_args(dist = list(window.size = 20L)))
#plot(pc.dtwlb)
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#dtw euclid
rm(pp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
#dtw euclid
rm(wp_series, pc.dtwlb, rs.Idx, rs, rs.val, i)
rm(CharTraj, CharTrajLabels, CharTrajMV)
rm(pp, pp_data, wp, wp_data, rs, rs.Idx, rs.val, i, pc.dtwlb, series)
#read projection profiles
pp <- scan("D:\\projection_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
pp_data <- strsplit(pp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(pp_data) <- sapply(pp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
pp_data <- lapply(pp_data, `[`, -1)
pp_data <- lapply(pp_data, as.numeric)
#read word profiles
wp <- scan("D:\\word_profiles.txt", what="", sep="\n")
# Separate elements by one or more whitepace
wp_data <- strsplit(wp, "[[:space:]]+")
# Extract the first vector element and set it as the list element name
names(wp_data) <- sapply(wp_data, `[[`, 1)
#names(y) <- sapply(y, function(x) x[[1]]) # same as above
# Remove the first vector element from each list element
wp_data <- lapply(wp_data, `[`, -1)
wp_data <- lapply(wp_data, as.numeric)
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
pp_series <- reinterpolate(pp_data, new.length = max(lengths(pp_data)))
pp_series <- zscore(pp_series)
wp_series <- reinterpolate(wp_data, new.length = max(lengths(wp_data)))
wp_series <- zscore(wp_series)
lapply(pp_series, write, "d:/pp_series.txt", append=TRUE, ncolumns=1000)
lapply(wp_series, write, "d:/wp_series.txt", append=TRUE, ncolumns=1000)
library("dtwclust", lib.loc="~/R/win-library/3.4")
help(zscore)
